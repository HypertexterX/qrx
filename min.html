<!DOCTYPE html>
<app></app>
<script>
D = document
W = window
WL = W.location
H = history
O = 'os'
F = 'files'
L = localStorage
ONS = 'onsuccess'
SI = 'setItem'
RS = 'replaceState'

class OS {
  constructor() {
    // Core configuration
    this.root = D.querySelector('app')
    this.$ = {}
    
    // Listeners
    W.addEventListener('hashchange', () => this.R())
    
    // Start the system
    this.boot()
  }
  
  /**
  * System Entry Point
  * 1. Connects to IndexedDB
  * 2. Runs any file starting with 'boot/'
  * 3. Routes to the current URL hash
  */
  async boot() {
    await this.cdb()
    await this.b()
    await this.R()
  }
  
  /**
  * Database Connection
  * Generic IndexedDB boilerplate
  */
  cdb() {
    return new Promise((r, re) => {
      let q = indexedDB.open(O, 1)
      q.onupgradeneeded = (e) => {
        let db = e.target.result
        if (!db.objectStoreNames.contains(F)) {
          db.createObjectStore(F)
        }
      }
      q[ONS] = (e) => {
        this.db = e.target.result
        r()
      }
      q.onerror = re
    })
  }

  // gets database transations
  // m = mode
  tx(m='readonly') {
    return this.db.transaction(F, m).objectStore(F)
  }
  
  async write(k, v) {
    return new Promise((r) => {
      this.tx('readwrite').put(v, k)[ONS] = r
    })
  }
  
  async read(k) {
    return new Promise((r) => {
      this.tx().get(k)[ONS] = (e) => r(e.target.result)
    })
  }
  
  async getKeys() {
    return new Promise((r) => {
      this.tx().getAllKeys()[ONS] = (e) => r(e.target.result)
    })
  }
  
  // --- Plugin Architecture ---
  // n = name
  // p = plugin factory
  use(n, p) {
    this.$[n] = p
    // If plugin is a function, run it immediately passing the OS instance
    if (typeof p === 'function') p(this)
  }
  
  // --- Kernel Logic ---
  
  async b() {
    let k = await this.getKeys(),
      // Filter for any file starting with "boot" (e.g., boot/drivers, boot/theme)
      b = k.filter(k => k.startsWith('boot')).sort()
    
    for (let f of b) {
      let s = await this.read(f)
      try {
        // Execute boot scripts within the context of 'os'
        (new Function(O, s))(this)
      } catch (e) {
        console.error(`[Boot Error] ${f}:`, e)
      }
    }
  }
  
  async R() {
    // Parse URL: #filename?cmd=val
    let h = WL.hash.slice(1) || 'home',
      [fp, q] = h.split('?'),
      p = new URLSearchParams(q)
    
    // 1. Handle Direct Write (?w=content)
    if (p.has('w')) {
      await this.write(fp, p.get('w'))
      // Clean URL after write so reloading doesn't re-write
      H[RS](null, '', `#${fp}`)
    }
    
    // Setup API Config
    // Check URL for keys, save to LocalStorage, then Clean URL
    if (p.has('k')) {
      L[SI]('k', p.get('k'))
      p.delete('k')
      // Update URL without triggering reload, keeping other params like ?p=
      let newHash = p.toString() ? `${fp}?${p.toString()}` : fp
      H[RS](null, '', `#${newHash}`)
    }
    
    if (p.has('m')) {
      L[SI]('m', p.get('m'))
      p.delete('m')
      let newHash = p.toString() ? `${fp}?${p.toString()}` : fp
      H[RS](null, '', `#${newHash}`)
    }
    
    let k = L.getItem('k'),
      m = L.getItem('m') || 'gemini-3-pro-preview'
    
    // 2. Handle AI Generation (?p=...)
    if (p.has('p')) {
      if (!k) {
        this.r(`<h3>Configuration Required</h3><p>No API Key found. Please add <code>?k=YOUR_KEY</code> to the URL.</p>`)
        return
      }
      // We pass the full current URL as the request, as it contains the prompt in ?p=
      await this.g(
        fp, 
        k, 
        m, 
        WL.href 
      )
      return
    }
    
    // 3. Standard Load
    // Load content from DB and render into <app>
    let c = await this.read(fp)
    
    // If no content, show minimal error allowing for creation
    this.r(c || '')
  }
    
  /**
  * Renders HTML content and re-activates <script> tags
  * Browsers do not execute scripts inserted via innerHTML automatically
  */
  r(h) {
    this.root.innerHTML = h
    this.RS(this.root)
  }
  
  // Rehydrate scripts
  RS(c) {
    c.querySelectorAll('script').forEach(o => {
      let s = D.createElement('script')
      // Copy attributes (src, type, etc)
      Array.from(o.attributes).forEach(attr => {
        s.setAttribute(attr.name, attr.value)
      })
      s.textContent = o.textContent
      o.parentNode.replaceChild(s, o)
    })
  }
  
  /**
  * Streams from Gemini API directly into the DOM
  * Saves the final result to DB when finished
  */
  async g(f, k, m, u) {
    this.root.innerHTML = '<i>Thinking...</i>'
    
    // Context: We give the LLM the current file content (if any) as context
    let c = await this.read(f) || '',
      p = {
        contents: [{
          parts: [{ 
            text: `<SYSTEM>You are an OS. Generate a valid HTML/JS Single Page App.</SYSTEM><CONTEXT>${c}</CONTEXT><USER_REQUEST>${u}</USER_REQUEST>` 
          }]
        }]
      }
    
    try {
      // Added &alt=sse to force Server-Sent Events format so 'data: ' parsing works
      let r = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${m}:streamGenerateContent?key=${k}&alt=sse`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(p)
      })
      
      if (!r.ok) {
        let e = await r.text()
        throw new Error(`API Error ${r.status}: ${e}`)
      }
      
      let re = r.body.getReader(), de = new TextDecoder(), b = '', fT = ''
      
      // Stream Loop
      while (true) {
        let { done, value } = await re.read()
        if (done) break
        
        b += de.decode(value, { stream: true })
        
        // Parse Gemini's JSON stream format (SSE)
        // Data comes in chunks: "data: { ... }\n\n"
        let ls = b.split('\n')
        b = ls.pop() // Keep incomplete line in buffer
        
        for (let l of ls) {
          if (l.startsWith('data: ')) {
            try {
              let j = JSON.parse(l.slice(6)),
                t = j.candidates?.[0]?.content?.parts?.[0]?.text
              if (t) {
                fT += t
                // Live update URL (optional visual feedback) or partial DOM
                // For simplicity/stability, we update the whole root here
                this.root.innerHTML = fT
              }
            } catch (e) { /* Ignore parsing errors on partial chunks */ }
          }
        }
      }
      
      // Final Save
      await this.write(f, fT)
      
      // Final Execution (Scripts won't run until this call)
      this.RS(this.root)
      
      // Clean URL
      H[RS](null, '', `#${f}`)
      
    } catch (err) {
      this.root.innerHTML = `<pre>${err.message}</pre>`
    }
  }
}

// Instantiate the global Operating System
os = new OS()
</script>