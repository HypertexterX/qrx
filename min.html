<!DOCTYPE html>
<app></app>
<script>
// Variable name dictionary
$Q = 'querySelectorAll'
C = 'CONTEXT'
D = document
F = 'files'
GI = 'getItem'
H = history
IH = 'innerHTML'
L = localStorage
O = 'os'
ONS = 'onsuccess'
P = Promise
R = 'root'
RS = 'replaceState'
S = 'SYSTEM'
SI = 'setItem'
TC = 'textContent'
UR = 'USER_REQUEST'
W = window
WL = W.location

class OS {
  constructor() {
    // Core configuration
    this[R] = D[$Q]('app')[0]
    this.$ = {}
    
    // Listeners
    W.addEventListener('hashchange', () => this.R())
    
    // Start the system
    this.boot(this)
  }
  
  /**
  * System Entry Point
  * 1. Connects to IndexedDB
  * 2. Runs any file starting with 'boot/'
  * 3. Routes to the current URL hash
  */
  async boot(T) {
    await T.cdb(T)
    await T.b(T)
    await T.R(T)
  }
  
  /**
  * Database Connection
  * Generic IndexedDB boilerplate
  */
  cdb(T) {
    return new P((r, re) => {
      let q = indexedDB.open(O, 1), db
      q.onupgradeneeded = (e) => {
        db = e.target.result
        if (!db.objectStoreNames.contains(F)) {
          db.createObjectStore(F)
        }
      }
      q[ONS] = (e) => {
        T.db = e.target.result
        r()
      }
      q.onerror = re
    })
  }

  // gets database transations
  // m = mode
  tx(T, m='readonly') {
    return T.db.transaction(F, m).objectStore(F)
  }
  
  async write(T, k, v) {
    return new P((r) => T.tx(T, 'readwrite').put(v, k)[ONS] = r)
  }
  
  async read(T, k) {
    return new P((r) => T.tx(T, ).get(k)[ONS] = (e) => r(e.target.result))
  }
  
  async getKeys(T) {
    return new P((r) => T.tx(T, ).getAllKeys()[ONS] = (e) => r(e.target.result))
  }
  
  // --- Plugin Architecture ---
  // n = name
  // p = plugin factory
  use(T, n, p) {
    T.$[n] = p
    // If plugin is a function, run it immediately passing the OS instance
    if (typeof p == 'function') p(T)
  }
  
  // --- Kernel Logic ---
  
  async b(T) {
    let k = await T.getKeys(T),
      // Filter for any file starting with "boot" (e.g., boot/drivers, boot/theme)
      b = k.filter(k => k.startsWith('boot')).sort(),
      s
    
    for (let f of b) {
      s = await T.read(T, f)
      try {
        // Execute boot scripts within the context of 'os'
        (new Function(O, s))(T)
      } catch (e) {
        console.error(`[Boot Error] ${f}:`, e)
      }
    }
  }
  
  async R(T) {
    // Parse URL: #filename?cmd=val
    let h = WL.hash.slice(1) || 'home',
      [fp, q] = h.split('?'),
      p = new URLSearchParams(q),
      hn,
      api,
      k,
      c
    
    // 1. Handle Direct Write (?w=content)
    if (p.has('w')) {
      await T.write(T, fp, p.get('w'))
      // Clean URL after write so reloading doesn't re-write
      H[RS](null, '', `#${fp}`)
    }
    
    // Setup API Config
    // k = api key
    // m = api model
    // s = system prompt
    api = ['k', 'm', 's']
    for (let a of api) {
      if (p.has(a)) {
        L[SI](a, p.get(a))
        p.delete(a)
        H[RS](null, '', `#${p.toString() ? `${fp}?${p.toString()}` : fp}`)
      }
    }
    
    k = L[GI]('k')
    
    // 2. Handle AI Generation (?p=...)
    if (p.has('p')) {
      if (!k) {
        T.r(T, `missing api key`)
        return
      }
      // We pass the full current URL as the request, as it contains the prompt in ?p=
      await T.g(T, fp, L[GI]('s'), k, L[GI]('m'), WL.href)
      return
    }
    
    // 3. Standard Load
    // Load content from DB and render into <app>
    c = await T.read(T, fp)
    
    // If no content, show minimal error allowing for creation
    T.r(T, c || '')
  }
    
  /**
  * Renders HTML content and re-activates <script> tags
  * Browsers do not execute scripts inserted via innerHTML automatically
  */
  r(T, h) {
    T[R][IH] = h
    T.RS(T, T[R])
  }
  
  // Rehydrate scripts
  RS(T, c) {
    c[$Q]('script').forEach(o => {
      let s = D.createElement('script')
      // Copy attributes (src, type, etc)
      Array.from(o.attributes).forEach(attr => {
        s.setAttribute(attr.name, attr.value)
      })
      s[TC] = o[TC]
      o.parentNode.replaceChild(s, o)
    })
  }
  
  /**
  * Streams from Gemini API directly into the DOM
  * Saves the final result to DB when finished
  */
  async g(T, f, s, k, m, u) {
    T[R][IH] = 'Thinking...'
    
    // Context: We give the LLM the current file content (if any) as context
    let c = await T.read(T, f) || '',
      p = {
        contents: [{
          parts: [{ 
            text: `<${S}>${s}</${S}><${C}>${c}</${C}><${UR}>${u}</${UR}>` 
          }]
        }]
      },
      r,e,re,done,value,ls,l,j,t

    
    try {
      // Added &alt=sse to force Server-Sent Events format so 'data: ' parsing works
      r = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${m}:streamGenerateContent?key=${k}&alt=sse`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(p)
      })
      
      if (!r.ok) {
        e = await r.text()
        throw new Error(`API Error ${r.status}: ${e}`)
      }
      
      re = r.body.getReader(), de = new TextDecoder(), b = '', fT = ''
      
      // Stream Loop
      while (true) {
        ({ done, value } = await re.read())
        if (done) break
        
        b += de.decode(value, { stream: true })
        
        // Parse Gemini's JSON stream format (SSE)
        // Data comes in chunks: "data: { ... }\n\n"
        ls = b.split('\n')
        b = ls.pop() // Keep incomplete line in buffer
        
        for (l of ls) {
          if (l.startsWith('data: ')) {
            try {
              j = JSON.parse(l.slice(6))
              t = j.candidates?.[0]?.content?.parts?.[0]?.text
              if (t) {
                fT += t
                // Live update URL (optional visual feedback) or partial DOM
                // For simplicity/stability, we update the whole root here
                T[R][IH] = fT
              }
            } catch (e) { /* Ignore parsing errors on partial chunks */ }
          }
        }
      }
      
      // Final Save
      await T.write(T, f, fT)
      
      // Final Execution (Scripts won't run until this call)
      T.RS(T, T[R])
      
      // Clean URL
      H[RS](null, '', `#${f}`)
      
    } catch (err) {
      T[R][IH] = `${err.message}`
    }
  }
}

// Instantiate the global Operating System
os = new OS()
</script>