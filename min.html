<!DOCTYPE html>
<style>:root{color-scheme:dark}</style>
<app></app>
<script>(() => {
let $D = document,
    $w = window,
    $wl = $w.location

class OS {
  constructor() {
    // Core configuration
    this.name = 'os'
    this.storeName = 'files'
    this.root = $D.querySelector('app')
    this.plugins = {}
    
    // Listeners
    $w.addEventListener('hashchange', () => this.route())
    
    // Start the system
    this.boot()
  }
  
  /**
  * System Entry Point
  * 1. Connects to IndexedDB
  * 2. Runs any file starting with 'boot/'
  * 3. Routes to the current URL hash
  */
  async boot() {
    await this.connectDB()
    await this.runBootloader()
    await this.route()
  }
  
  /**
  * Database Connection
  * Generic IndexedDB boilerplate
  */
  connectDB() {
    return new Promise((resolve, reject) => {
      let r = indexedDB.open(this.name, 1)
      r.onupgradeneeded = (e) => {
        let db = e.target.result
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName)
        }
      }
      r.onsuccess = (e) => {
        this.db = e.target.result
        resolve()
      }
      r.onerror = reject
    })
  }

  // gets database transations
  // m = mode
  dbTx(m, rw='readonly') {
    return this.db.transaction(this.storeName, m).objectStore(this.storeName)
  }
  
  async write(key, value) {
    return new Promise((resolve) => {
      this.dbTx('readwrite').put(value, key).onsuccess = resolve
    })
  }
  
  async read(key) {
    return new Promise((resolve) => {
      this.dbTx().get(key).onsuccess = (e) => resolve(e.target.result)
    })
  }
  
  async getKeys() {
    return new Promise((resolve) => {
      this.dbTx().getAllKeys().onsuccess = (e) => resolve(e.target.result)
    })
  }
  
  // --- Plugin Architecture ---
  
  use(name, pluginFactory) {
    this.plugins[name] = pluginFactory
    // If plugin is a function, run it immediately passing the OS instance
    if (typeof pluginFactory === 'function') pluginFactory(this)
  }
  
  // --- Kernel Logic ---
  
  async runBootloader() {
    let keys = await this.getKeys(),
      // Filter for any file starting with "boot" (e.g., boot/drivers, boot/theme)
      bootFiles = keys.filter(k => k.startsWith('boot')).sort()
    
    for (let file of bootFiles) {
      let scriptContent = await this.read(file)
      try {
        // Execute boot scripts within the context of 'os'
        (new Function('os', scriptContent))(this)
      } catch (e) {
        console.error(`[Boot Error] ${file}:`, e)
      }
    }
  }
  
  async route() {
    // Parse URL: #filename?cmd=val
    let hash = $wl.hash.slice(1) || 'home',
      [filePath, queryStr] = hash.split('?'),
      params = new URLSearchParams(queryStr)
    
    // 1. Handle Direct Write (?w=content)
    if (params.has('w')) {
      await this.write(filePath, params.get('w'))
      // Clean URL after write so reloading doesn't re-write
      history.replaceState(null, '', `#${filePath}`)
    }
    
    // Setup API Config
    // Check URL for keys, save to LocalStorage, then Clean URL
    if (params.has('apiKey')) {
      localStorage.setItem('apiKey', params.get('apiKey'))
      params.delete('apiKey')
      // Update URL without triggering reload, keeping other params like ?p=
      let newHash = params.toString() ? `${filePath}?${params.toString()}` : filePath
      history.replaceState(null, '', `#${newHash}`)
    }
    
    if (params.has('apiModel')) {
      localStorage.setItem('apiModel', params.get('apiModel'))
      params.delete('apiModel')
      let newHash = params.toString() ? `${filePath}?${params.toString()}` : filePath
      history.replaceState(null, '', `#${newHash}`)
    }
    
    let apiKey = localStorage.getItem('apiKey'),
      apiModel = localStorage.getItem('apiModel') || 'gemini-3-pro-preview'
    
    // 2. Handle AI Generation (?p=...)
    if (params.has('p')) {
      if (!apiKey) {
        this.render(`
                  <h3>Configuration Required</h3>
                  <p>No API Key found. Please add <code>?apiKey=YOUR_KEY</code> to the URL.</p>
              `)
        return
      }
      // We pass the full current URL as the request, as it contains the prompt in ?p=
      await this.generateAndRender(
      filePath, 
      apiKey, 
      apiModel, 
      $wl.href 
      )
      return
    }
    
    // 3. Standard Load
    // Load content from DB and render into <app>
    let content = await this.read(filePath)
    
    // If no content, show minimal error allowing for creation
    this.render(content || `
        <h3>Error #0x404</h3>
        <p>File #${filePath} does not exist yet.</p>
        <p>Use <code>?w=content</code> to create it manually, or <code>?p=prompt</code> to generate it.</p>
    `)
  }
    
  /**
  * Renders HTML content and re-activates <script> tags
  * Browsers do not execute scripts inserted via innerHTML automatically
  */
  render(html) {
    this.root.innerHTML = html
    this.rehydrateScripts(this.root)
  }
  
  rehydrateScripts(container) {
    container.querySelectorAll('script').forEach(oldScript => {
      let newScript = $D.createElement('script')
      // Copy attributes (src, type, etc)
      Array.from(oldScript.attributes).forEach(attr => {
        newScript.setAttribute(attr.name, attr.value)
      })
      newScript.textContent = oldScript.textContent
      oldScript.parentNode.replaceChild(newScript, oldScript)
    })
  }
  
  /**
  * Streams from Gemini API directly into the DOM
  * Saves the final result to DB when finished
  */
  async generateAndRender(filePath, key, model, promptUrl) {
    this.root.innerHTML = '<i>Thinking...</i>'
    
    // Context: We give the LLM the current file content (if any) as context
    let currentContext = await this.read(filePath) || '',
      payload = {
        contents: [{
          parts: [{ 
            text: `<SYSTEM>You are an OS. Generate a valid HTML/JS Single Page App.</SYSTEM><CONTEXT>${currentContext}</CONTEXT><USER_REQUEST>${promptUrl}</USER_REQUEST>` 
          }]
        }]
      }
    
    try {
      // Added &alt=sse to force Server-Sent Events format so 'data: ' parsing works
      let response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/${model}:streamGenerateContent?key=${key}&alt=sse`, 
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      }
      )
      
      if (!response.ok) {
        let errText = await response.text()
        throw new Error(`API Error ${response.status}: ${errText}`)
      }
      
      let reader = response.body.getReader(),
        decoder = new TextDecoder()
      let buffer = '',
        fullText = ''
      
      // Stream Loop
      while (true) {
        let { done, value } = await reader.read()
        if (done) break
        
        buffer += decoder.decode(value, { stream: true })
        
        // Parse Gemini's JSON stream format (SSE)
        // Data comes in chunks: "data: { ... }\n\n"
        let lines = buffer.split('\n')
        buffer = lines.pop() // Keep incomplete line in buffer
        
        for (let line of lines) {
          if (line.startsWith('data: ')) {
            try {
              let json = JSON.parse(line.slice(6)),
                text = json.candidates?.[0]?.content?.parts?.[0]?.text
              if (text) {
                fullText += text
                // Live update URL (optional visual feedback) or partial DOM
                // For simplicity/stability, we update the whole root here
                this.root.innerHTML = fullText
              }
            } catch (e) { /* Ignore parsing errors on partial chunks */ }
          }
        }
      }
      
      // Final Save
      await this.write(filePath, fullText)
      
      // Final Execution (Scripts won't run until this call)
      this.rehydrateScripts(this.root)
      
      // Clean URL
      history.replaceState(null, '', `#${filePath}`)
      
    } catch (err) {
      this.root.innerHTML = `<pre>${err.message}</pre>`
    }
  }
}

// Instantiate the global Operating System
os = new OS()
})()</script>