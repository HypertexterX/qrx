<!DOCTYPE html>
<app id=A></app>
<style>:root{color-scheme:dark}</style>
<script>
D=document
J=JSON
L=localStorage
H=history
RS='replaceState'
W=window
// DB Name determined by Path (Multiverse Support)
O=location.pathname.slice(1)||'os'
F='files';ONS='onsuccess'

class OS {
  constructor() {
    W.onhashchange = () => this.run()
    this.boot()
  }

  async boot() {
    await this.cdb()
    // Run boot files (Skip if ?safe)
    if(!new URLSearchParams(location.hash.split('?')[1]).has('safe')) {
      let k = await this.keys(),
          b = k.filter(x => x.startsWith('boot')).sort()
      for (let f of b) {
        try {
          let s = await this.read(f)
          (new Function(O, s))(this)
        } catch(e) { console.error(f,e) }
      }
    }
    this.run()
  }

  cdb() {
    return new Promise(r => {
      let q = indexedDB.open(O)
      q.onupgradeneeded = e => e.target.result.createObjectStore(F)
      q[ONS] = e => { this.db = e.target.result; r() }
    })
  }

  tx(m='readonly') {
    return this.db.transaction(F, m).objectStore(F)
  }

  write(k, v) {
    return new Promise(r => this.tx('readwrite').put(v, k)[ONS] = r)
  }

  read(k) {
    return new Promise(r => this.tx().get(k)[ONS] = e => r(e.target.result))
  }

  keys() {
    return new Promise(r => this.tx().getAllKeys()[ONS] = e => r(e.target.result))
  }

  async run() {
    // Redirect empty hash
    if(!location.hash) { H[RS](0,'','#home'); return this.run() }

    let h = location.hash.slice(1),
        [f, q] = h.split('?'),
        p = new URLSearchParams(q)

    // 1. Direct Write (?w=...&a)
    if (p.has('w')) {
      let v = p.get('w')
      if(p.has('a')) {
        let old = await this.read(f)
        if(old) v = old + v
      }
      await this.write(f, v)
      H[RS](0,'','#'+f)
    }
    
    // 2. Execute (?x=...)
    if (p.has('x')) {
      try {
        await (new Function(O, p.get('x')))(this)
      } catch(e) { console.error(e) }
      H[RS](0,'','#'+f)
    }

    // 3. Config
    for(let k of ['k','m','s','h']) {
      if(p.has(k)) {
        L.setItem(k, p.get(k))
        p.delete(k)
        H[RS](0,'','#'+(p.toString()?`${f}?${p}`:f))
      }
    }

    // 4. AI Gen (?p=...&a)
    if (p.has('p')) return this.gen(f, p.get('p'), p.has('a'))

    // 5. Render
    let c = await this.read(f)
    
    // Auto-Index
    if(!c) c = (await this.keys()).map(k=>`<a href="#${k}">${k}</a>`).join('<br>')
    
    if(p.has('safe')) A.innerHTML = c
    else this.rehydrate(c)
  }

  rehydrate(h) {
    A.innerHTML = h
    A.querySelectorAll('script').forEach(o => {
      let s = D.createElement('script')
      Array.from(o.attributes).forEach(a => s.setAttribute(a.name, a.value))
      s.text = o.textContent
      o.replaceWith(s)
    })
  }

  async gen(f, prompt, app) {
    let [k,m,s,h] = ['k','m','s','h'].map(x=>L.getItem(x)),
        c = await this.read(f) || '',
        g = h == 'google',
        msg = `<SYS>${s}</SYS><FILE>${c}</FILE><REQ>${prompt}</REQ>`,
        u = g ? `https://generativelanguage.googleapis.com/v1beta/models/${m}:generateContent?key=${k}` : h,
        b = g ? { contents: [{ parts: [{ text: msg }] }] }
              : { model: m, messages: [{ role: 'user', content: msg }] },
        head = {'Content-Type': 'application/json'},
        req, res, txt
    
    if(!g && k) head['Authorization'] = `Bearer ${k}`
    
    A.innerHTML = 'Thinking...'
    
    try {
      req = await fetch(u, { method: 'POST', headers: head, body: J.stringify(b) })
      res = await req.json()
      txt = g ? res.candidates?.[0]?.content?.parts?.[0]?.text
              : res.choices?.[0]?.message?.content
      
      if(txt) {
        if(app) txt = c + txt
        await this.write(f, txt)
        this.rehydrate(txt)
        H[RS](0,'','#'+f)
      }
    } catch(e) { A.innerHTML = e }
  }
}

os = new OS()
</script>