<!DOCTYPE html>
<style>:root{color-scheme:dark}</style>
<app></app>
<script>
class OS {
    constructor() {
        // Core configuration
        this.dbName = 'os'
        this.storeName = 'files'
        this.root = document.querySelector('app')
        this.plugins = {}
        
        // Listeners
        window.addEventListener('hashchange', () => this.route())
        
        // Start the system
        this.boot()
    }

    /**
     * System Entry Point
     * 1. Connects to IndexedDB
     * 2. Runs any file starting with 'boot/'
     * 3. Routes to the current URL hash
     */
    async boot() {
        await this.connectDB()
        await this.runBootloader()
        await this.route()
    }

    /**
     * Database Connection
     * Generic IndexedDB boilerplate
     */
    connectDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, 1)
            request.onupgradeneeded = (e) => {
                const db = e.target.result
                if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName)
                }
            }
            request.onsuccess = (e) => {
                this.db = e.target.result
                resolve()
            }
            request.onerror = reject
        })
    }

    // --- File System Abstractions ---

    async write(key, value) {
        return new Promise((resolve) => {
            const tx = this.db.transaction(this.storeName, 'readwrite')
            tx.objectStore(this.storeName).put(value, key).onsuccess = resolve
        })
    }

    async read(key) {
        return new Promise((resolve) => {
            const tx = this.db.transaction(this.storeName, 'readonly')
            tx.objectStore(this.storeName).get(key).onsuccess = (e) => resolve(e.target.result)
        })
    }

    async getKeys() {
        return new Promise((resolve) => {
            const tx = this.db.transaction(this.storeName, 'readonly')
            tx.objectStore(this.storeName).getAllKeys().onsuccess = (e) => resolve(e.target.result)
        })
    }

    // --- Plugin Architecture ---

    use(name, pluginFactory) {
        this.plugins[name] = pluginFactory
        // If plugin is a function, run it immediately passing the OS instance
        if (typeof pluginFactory === 'function') pluginFactory(this)
    }

    // --- Kernel Logic ---

    async runBootloader() {
        const keys = await this.getKeys()
        // Filter for any file starting with "boot" (e.g., boot/drivers, boot/theme)
        const bootFiles = keys.filter(k => k.startsWith('boot')).sort()
        
        for (const file of bootFiles) {
            const scriptContent = await this.read(file)
            try {
                // Execute boot scripts within the context of 'os'
                (new Function('os', scriptContent))(this)
            } catch (e) {
                console.error(`[Boot Error] ${file}:`, e)
            }
        }
    }

    async route() {
        // Parse URL: #filename?cmd=val
        const hash = window.location.hash.slice(1) || 'home'
        const [filePath, queryStr] = hash.split('?')
        const params = new URLSearchParams(queryStr)

        // 1. Handle Direct Write (?w=content)
        if (params.has('w')) {
            await this.write(filePath, params.get('w'))
            // Clean URL after write so reloading doesn't re-write
            history.replaceState(null, '', `#${filePath}`)
        }

        // Setup API Config
        // Check URL for keys, save to LocalStorage, then Clean URL
        if (params.has('apiKey')) {
            localStorage.setItem('apiKey', params.get('apiKey'))
            params.delete('apiKey')
            // Update URL without triggering reload, keeping other params like ?p=
            const newHash = params.toString() ? `${filePath}?${params.toString()}` : filePath
            history.replaceState(null, '', `#${newHash}`)
        }
        
        if (params.has('apiModel')) {
            localStorage.setItem('apiModel', params.get('apiModel'))
            params.delete('apiModel')
            const newHash = params.toString() ? `${filePath}?${params.toString()}` : filePath
            history.replaceState(null, '', `#${newHash}`)
        }

        const apiKey = localStorage.getItem('apiKey')
        const apiModel = localStorage.getItem('apiModel') || 'gemini-3-pro-preview'

        // 2. Handle AI Generation (?p=...)
        if (params.has('p')) {
            if (!apiKey) {
                this.render(`
                    <h3>Configuration Required</h3>
                    <p>No API Key found. Please add <code>?apiKey=YOUR_KEY</code> to the URL.</p>
                `)
                return
            }
            // We pass the full current URL as the request, as it contains the prompt in ?p=
            await this.generateAndRender(
                filePath, 
                apiKey, 
                apiModel, 
                window.location.href 
            )
            return
        }

        // 3. Standard Load
        // Load content from DB and render into <app>
        const content = await this.read(filePath)
        
        // If no content, show minimal error allowing for creation
        this.render(content || `
            <h3>Error #0x404</h3>
            <p>File #${filePath} does not exist yet.</p>
            <p>Use <code>?w=content</code> to create it manually, or <code>?p=prompt</code> to generate it.</p>
        `)
    }

    /**
     * Renders HTML content and re-activates <script> tags
     * Browsers do not execute scripts inserted via innerHTML automatically
     */
    render(html) {
        this.root.innerHTML = html
        this.rehydrateScripts(this.root)
    }

    rehydrateScripts(container) {
        container.querySelectorAll('script').forEach(oldScript => {
            const newScript = document.createElement('script')
            // Copy attributes (src, type, etc)
            Array.from(oldScript.attributes).forEach(attr => {
                newScript.setAttribute(attr.name, attr.value)
            })
            newScript.textContent = oldScript.textContent
            oldScript.parentNode.replaceChild(newScript, oldScript)
        })
    }

    /**
     * Streams from Gemini API directly into the DOM
     * Saves the final result to DB when finished
     */
    async generateAndRender(filePath, key, model, promptUrl) {
        this.root.innerHTML = '<i>Thinking...</i>'
        
        // Context: We give the LLM the current file content (if any) as context
        const currentContext = await this.read(filePath) || ''
        
        const payload = {
            contents: [{
                parts: [{ 
                    text: `<SYSTEM>You are an OS. Generate a valid HTML/JS Single Page App.</SYSTEM><CONTEXT>${currentContext}</CONTEXT><USER_REQUEST>${promptUrl}</USER_REQUEST>` 
                }]
            }]
        }

        try {
            // Added &alt=sse to force Server-Sent Events format so 'data: ' parsing works
            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/${model}:streamGenerateContent?key=${key}&alt=sse`, 
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }
            )

            if (!response.ok) {
                const errText = await response.text()
                throw new Error(`API Error ${response.status}: ${errText}`)
            }

            const reader = response.body.getReader()
            const decoder = new TextDecoder()
            let buffer = ''
            let fullText = ''

            // Stream Loop
            while (true) {
                const { done, value } = await reader.read()
                if (done) break
                
                buffer += decoder.decode(value, { stream: true })
                
                // Parse Gemini's JSON stream format (SSE)
                // Data comes in chunks: "data: { ... }\n\n"
                const lines = buffer.split('\n')
                buffer = lines.pop() // Keep incomplete line in buffer

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const json = JSON.parse(line.slice(6))
                            const text = json.candidates?.[0]?.content?.parts?.[0]?.text
                            if (text) {
                                fullText += text
                                // Live update URL (optional visual feedback) or partial DOM
                                // For simplicity/stability, we update the whole root here
                                this.root.innerHTML = fullText
                            }
                        } catch (e) { /* Ignore parsing errors on partial chunks */ }
                    }
                }
            }

            // Final Save
            await this.write(filePath, fullText)
            
            // Final Execution (Scripts won't run until this call)
            this.rehydrateScripts(this.root)
            
            // Clean URL
            history.replaceState(null, '', `#${filePath}`)

        } catch (err) {
            this.root.innerHTML = `<pre>${err.message}</pre>`
        }
    }
}

// Instantiate the global Operating System
const os = new OS()
</script>
