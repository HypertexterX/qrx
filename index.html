<!DOCTYPE html>
<style>:root{color-scheme:dark; font-family: monospace; white-space: pre-wrap}</style>
<app id=A></app>
<script id=S>
D=document
J=JSON
L=localStorage
H=history
RS='replaceState'
W=window
// DB Name determined by Path (Multiverse Support)
O=location.pathname.slice(1)||'os'
F='files';ONS='onsuccess'

class OS {
  constructor() {
    W.onhashchange = () => this.run()
    this.boot()
  }

  async boot() {
    this.db = await this.cdb()
    if(O!='os') this.os = await this.cdb('os')

    // Run boot files (Skip if ?safe)
    if(!new URLSearchParams(location.hash.split('?')[1]).has('safe')) {
      let q = IDBKeyRange.bound('boot', 'boot\uffff'),
          b = await this.keys(q)
      if(this.os) b = [...new Set([...b, ...await this.keys(q, this.os)])]

      for (let f of b) {
        try {
          (new Function(O, await this.read(f)))(this)
        } catch(e) { console.error(f,e) }
      }
    }
    this.run()
  }

  cdb(n=O) {
    return new Promise(r => {
      let q = indexedDB.open(n)
      q.onupgradeneeded = e => e.target.result.createObjectStore(F)
      q[ONS] = e => r(e.target.result)
    })
  }

  tx(m='readonly', d=this.db) {
    return d.transaction(F, m).objectStore(F)
  }

  write(k, v) {
    return new Promise(r => this.tx('readwrite').put(v, k)[ONS] = r)
  }

  async read(k) {
    return (await this.get(k)) || (this.os && await this.get(k, this.os))
  }

  get(k, d) {
    return new Promise(r => this.tx('readonly', d).get(k)[ONS] = e => r(e.target.result))
  }

  keys(q, d) {
    return new Promise(r => this.tx('readonly', d).getAllKeys(q)[ONS] = e => r(e.target.result))
  }

  async run() {
    // Wait for DB
    if(!this.db) this.db = await this.cdb()

    // Redirect empty hash
    if(!location.hash) { H[RS](0,'','#home'); return this.run() }

    let h = location.hash.slice(1),
        [n, q] = h.split('?'), // n=View Name
        f = n,                 // f=Write Pointer
        p = new URLSearchParams(q),
        v = await this.read(n)||'', // v=Accumulator (Starts with View)
        app = false

    // Store the history
    q && this.write('H/'+Date.now(),h)

    // --- THE MACHINE TAPE ---
    for(let [k,val] of p) {
      let c;
      
      // 1. Dynamic Commands (cmd/*)
      if(c = await this.read('cmd/'+k)) {
        try {
          let r = await (new Function(O, 'v', 'arg', c))(this, v, val)
          if(r!==void 0) v = r
        } catch(e) { console.error(k,e) }
      }
      
      // 2. State
      else if(k=='a') app = val!='0'
      
      // 3. Pointer
      else if(k=='f') f = val

      // 4. Config
      else if('kmsh'.includes(k)) L.setItem(k, val)

      // 5. Pipeline
      else if('erup'.includes(k)) {
        let s = val
        if(k=='r') s = await this.read(val)||''
        if(k=='u') s = await (await fetch(val)).text()
        if(k=='p') s = await this.gen(v, val)
        v = app ? v + s : s
      }

      // 6. Action: Write (Manual)
      else if(k=='w') await this.write(f, v)

      // 7. Action: Execute
      else if(k=='x') {
        try {
          let r = await (new Function(O, 'v', val))(this, v)
          if(r!==void 0) v = r
        } catch(e){ console.error(e) }
      }
    }

    // --- NEW: Auto-Write ---
    // If commands were executed, dump the final accumulator to the current pointer
    if(q) await this.write(f, v)

    // Cleanup URL
    if(q) H[RS](0,'','#'+n)

    // Final Render (From Disk)
    let c = await this.read(n) || ''
    
    if(p.has('safe')) A.innerHTML = c
    else this.rehydrate(c)
  }

  rehydrate(h) {
    A.innerHTML = h
    A.querySelectorAll('script').forEach(o => {
      let s = D.createElement('script')
      Array.from(o.attributes).forEach(a => s.setAttribute(a.name, a.value))
      s.text = o.textContent
      o.replaceWith(s)
    })
  }

  async gen(ctx, prompt) {
    let [k,m,s,h] = ['k','m','s','h'].map(x=>L.getItem(x)),
        g = h == 'google',
        msg = (s||'') + ctx + prompt,
        u = g ? `https://generativelanguage.googleapis.com/v1beta/models/${m}:generateContent?key=${k}` : h,
        b = g ? { contents: [{ parts: [{ text: msg }] }] }
              : { model: m, messages: [{ role: 'user', content: msg }] },
        head = {'Content-Type': 'application/json'},
        req, res, txt
    
    if(!g && k) head['Authorization'] = `Bearer ${k}`
    
    A.innerHTML = 'Thinking...'
    
    try {
      req = await fetch(u, { method: 'POST', headers: head, body: J.stringify(b) })
      res = await req.json()
      txt = g ? res.candidates?.[0]?.content?.parts?.[0]?.text
              : res.choices?.[0]?.message?.content
    } catch(e) { txt = e.message }
    
    return txt || ''
  }
}

os = new OS()
</script>
